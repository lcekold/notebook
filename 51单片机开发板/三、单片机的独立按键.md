# 三、单片机的独立按键
## 1.独恋按键基本知识
键盘分为编码键盘和非编码键盘。键盘上闭合键的识别由专用的硬件编码器实现，并产生键编码号或键值的称为编码键盘，如计算机键盘。而靠软件编程来识别的键盘称为非编码键盘，在单片机组成的各种系统中，用的较多的是非编码键盘。非编码键盘又分为独立键盘和行列式键盘（常说的矩阵键盘）。在这一讲中我们介绍一下单片机中键盘使用。

我们首先看以下这个图：
<div align="center"><img src="https://img1.imgtp.com/2023/07/29/CcSmjzqv.png"></div>

 首先说明的是，上图的连法是不允许的，因为当按键按下之后，电源和地短接，会将导线直接烧毁。但是此处用作特例，假设导线不会烧毁。现在来提出一个问题，当按键按下以后，请问如果这时用万用表测量导线上任何一处的电压，得到的结果是VCC 还是GND 的电压？

  答案是：GND，即表示测出的电压为0V。为什么呢，因为导线上，对于两端的电平是一种类似于程序语言逻辑运算里面的“与”，即对于导线两端：有零即为零，只有全为一是才为一。理解了这点，按键的工作前提就有了。

  单片机的IO口既可作为输出也可作为输入使用，当检测按键时用的是它的输入功能，我们把按键的一端接地，另一端与单片机的某个I/O口相连，开始时先给该IO口赋一高电平，然后让单片机不断地检测该I/O口是杏变为低电平，当按键闭合时，即相当于该I/O口通过按键与地相连，变成低电平，程序一旦检测到I/O口变为低电平则说明按键被按下，然后执行相应的指令。

<br>
<br>
明白了单片机的一些基本原理，现在让我们回归现实，拿起手中的板子来亲身体验以下  
在单片机上，独立按键是这个：
<div align="center"><img src="https://img1.imgtp.com/2023/07/29/ahYjOfom.png"></div>

电路原理图是：
<div align="center"><img src="https://img1.imgtp.com/2023/07/29/EDi3DRT5.png"></div>

<font color="green">注意：K1接P3_1口，K2接P3_0口，顺序上是反过来的，不要搞错了。</font>

由原理图不难得知，由于独立按键右端接地，所以

>当连接独立按键的P3对应端口为低电平时，表示导通了。

比如，判断独立按键K1是否导通的代码就是P3_1==0。

由此，我们也可以理解“独立按键”的含义了：

>所谓独立，即这个电键并不是直接与电路相连而去控制电路的，而是通过我们对这个独立电键的操作所返回的信息来达成一定的判断条件，在判断条件之下控制电路的。比如我们按下K1，原电路并不会有什么改变，我们所做的只是将K1导通了而已。但是K1导通所带来的信息就是P3_1==0，在这条信息之下，我们就可以让程序去执行相应的操作了。

## 2.按键的抖动问题
<div align="center"><img src="https://img1.imgtp.com/2023/07/29/w97wLQKJ.png"></div>
<div align="center"><img src="https://img1.imgtp.com/2023/07/29/ga52vPUZ.png"></div>
还以图4为例，按键未按下之前，图4按键左端的导线因为连在VCC 上而显示高电平，右端显示低电平，按键按下后，按键闭合，整个导线都显示低电平，然后按键松开，又回到按键按下之前的电平状态。如果只考察按键左端的电平变化，应该是上图中所显示的一个负脉冲波形。但是，实际上，正确的波形应该是下图。相比于上图，大家都看到了在高低电平直接有一段锯齿一样的波形，这就是所谓的按键抖动。

         为什么会有按键抖动呢，原因很简单，接触式按键是靠机械的接触来实现开关作用的。这种接触方式就注定了它要经历一个“接触不稳定——正在稳定中——彻底稳定”的一种过程。就好比你用手抓紧一颗石头，即使你一开始就很用力的握紧，也不可能马上就达到最紧的状态，也要经历一个从握住到最紧握的过程。那么在这个过程里，接触式按键就处于一种徘徊在“闭合”与“断开”两者之间的状态。体现在电路中，就是在一小段时间内有非常多的“按下——抬起”动作。而这段抖动的时间，大概是10~20 毫秒，依不同的环境条件而定。

      解决这个问题常见的方法有软件去抖动和硬件去抖动。

      我们解释一下抖动：关于按键去抖动的解释，我们在手动按键的时候，由于机械抖动或是其它一些非人为的因素很有可能会造成误识别，一般手动按下一次键然后接着释放，按键两片金属膜接触的时间大约为50ms 左右，在按下瞬间到稳定的时间为5-10ms,在松开的瞬间到稳定的时间也为5-10ms，如果我们再首次检测到键被按下后延时10ms 左右再去检测，这时如果是干扰信号将不会被检测到，如果确实是有键被按下，则可确认，以上为按键识别去抖动的原理。

## 3.独立按键控制LED亮灭
### (1)首先先学习如何单独控制一个灯的亮灭（注：不依靠独立按键），代码如下：
```c++
#include <REGX52.H>

void main()
{
 //	P2=0xFE; // p2是对所有LED灯进行控制，不方便
	P2_0=0;  //P2_0则可以实现对单独一个LED灯的控制，而不需要连带控制其它的LED灯，这个也是在#include <REGX52.H>中包括的
	P2_0=1;
}

```

以上代码实现了对单独一个LED灯亮灭的控制


### (2)接下来我们学习依靠独立按键控制一个灯的亮灭
```c++
#include <REGX52.H>

void main()
{
	while(1)
	{
		if(P3_1==0)//检测这个独立按键是否被按下，P3_1是此独立按键在头文件中的声明，P3_1==0说明这个独立按键被按下
		{
			P2_0=0;//被按下就发光
		}
		else
		{
			P2_0=1;//松开就不发光
		}
	}
}

```
这样我们就实现了依靠一个独立按键控制LED灯的亮灭

### （3）一个有趣的做法，如果将if拿到循环体外会怎样
代码如下：
```c++
#include <REGX52.H>

void main()
{
	if(P3_1==0)
		{
			P2_0=0;
		}
		else
		{
			P2_0=1;
		}
	while(1)
	{
		
	}
}

```
但你在单片机上运行这段程序的时候会发现，刚开始LED灯不会亮，哪怕你已经按了独立按键，但是当你关闭单片机后一直摁住独立按键，然后再打开单片机就会发现LED灯亮了，松开后LED灯熄灭，但是当你再去按住独立按键时，LED灯再也不会亮了。事实上当我们想要从头开始一段代码的运行，不需要关闭单片机再打开，我们可以按单片机上的复位按钮，也可以实现这一过程。

你可以去感受一下这段代码的运行。然后依靠这几天学习到的知识自己解答一下为什么会这样。

## 4.实现按一次后LED灯常量，再按一次按键LED灯熄灭，同时解决按键抖动问题
代码如下：
```c
#include <REGX52.H>

void Delay1ms(unsigned int xms)		//@12.000MHz
{
	unsigned char data i, j;
	while(xms)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
		xms--;
	}
}


void main()
{
	
	while(1)
	{
		if(P3_1==0)//检测是否按下按键
		{
			Delay(20);//设置一个20ms的延时来抵消按键抖动的影响
			while(P3_1==0);//如果手一直按着按键就一直循环，不执行操作,说白了就是检测按键是否松开。
			Delay(20);
			
			
			P2_0=~P2_0;//对该LED灯的状态进行取反，注意是对状态进行取反。
		}
	}
}


```

## 5.独立按键控制LED显示二进制
代码如下：
```c
#include <REGX52.H>

void Delay(unsigned int xms)		//@12.000MHz
{
	unsigned char data i, j;
	while(xms--)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
	}
}

int main()
{
	unsigned char LEDNum=0;
		while(1)
		{
			if(P3_1==0)
			{
				Delay(20);
				while(P3_1==0);
				Delay(20);
				LEDNum++; 
				P2=~LEDNum;
			}
		}
}
```

## 独立按键控制LED移位
同一方向移动
代码如下：
```c
#include <REGX52.H>

void Delay(unsigned int xms)		//@12.000MHz
{
	unsigned char data i, j;
	while(xms--)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
	}
}

int main()
{
	unsigned int Lednum=0;
	Lednum=0x01;
	while(1)
	{
		if(Lednum==0x100)
		{
			Lednum=0x01;
		}
			if(P3_1==0)
			{
				Delay(20);
				while(P3_1==0);
				Delay(20);
				P2=~Lednum;
				Lednum=Lednum<<1;
			}
	}
}
```