# 四、数码管
## 1.数码管简介
### （1）数码管电路
#### 1.1单个数码管
<div align="center"><img src="https://img1.imgtp.com/2023/08/02/yWnn5xxF.png"></div>
一个数码管是由a、b、c、d、e、f、g、dp八个二极管组成，八个LED一端接在一起，另一端引脚引出来。二极管如果阳极连在一起，就是共阳极数码管，阴极连在一起，就是共阴极数码管。

如上图，是一个共阴极数码管，要使数码管显示不同的数字，只需点亮对应LED即可。如：数码管显示“0”，则a、b、c、d、e、f六个LED亮，g、dp这俩个LED灭，即可显示“0”。

#### 1.2多个数码管
<div align="center" ><img src="https://img1.imgtp.com/2023/08/02/cvwPPHcr.png" height="200"></div>

上图所示的六个数码管，在使用时，需要程序选定使用哪几个数码管，这就是“位选”，选定数码管后再对选定的数码管进行操作，其操作与单个数码管的操作一致（接下来还会进一步详解），这就是“段选”。

### (2)数码管与芯片的连接
#### 2.1为什么要使用锁存器
二极管正常工作时需要5mA以上的电流，若数码管引脚和芯片引脚直接相连，芯片的I/O口无法输出这么大的电流，原因是芯片I/0口输出过大电流可能使温度升高从而对芯片造成损坏，对于共阴极的数码管，可以在阳极处接上拉电阻，对于共阳极的数码管，可以在阴极处接下拉电阻，但是也使得“位选”需做另外的处理。

引入锁存器，利用其输出电流大的特点，有效的解决了LED工作电流问题，而且还可以利用锁存器进行“位选”、“段选”。

#### 2.2锁存器的电路连接
<div align="center"><img src="https://img1.imgtp.com/2023/08/02/CWGzxgTR.png"></div>
上图所示，连接俩块锁存器，U1控制段选，U2控制位选
<div align="center"><img src="https://img1.imgtp.com/2023/08/02/7Ekzy4gy.png"></div>
根据电路图，OE始终接地，所以锁存器工作状态只有前三种，当LE软件置1时，锁存器的输入端D与输出端Q同高电平，同低电平，当LE软件置0时，锁存器输出为Q0。

由电路图可得，电路连接为：

单片机的芯片引脚P00—>P07分别接U1锁存器的D0——>D7,单片机的芯片引脚P00—>P07分别接U2锁存器的D0——>D7,也就是说U1、U2俩锁存器都与P0相连，所以在数码管工作状态下，俩个锁存器不能同时处于打开状态，即俩个锁存器的LE不能同时为高电平。锁存器U1的输出接数码管的LED阳极，锁存器U2的输出接数码管的WE，控制“数码管选择”。

锁存器U2控制位选，U2打开时，U1关闭，此时U2的输入和输出同高、同低电平。如下图，若使用数码管1，则只需D0置0，其他引脚置1，即芯片P00输出为0，P01——>P07输出为1，即P0寄存器的状态值为0xfe（上面低位，从下往上读）

<div align="center"><img src="https://img1.imgtp.com/2023/08/02/8kfSD8GI.png"></div>

锁存器U1控制段选，如刚刚位选了数码管1，则接下来段选是对数码管1的操作。此时关闭U2，打开U1，即U2的LE软件置0，U1的LE软件置1，而U2的LE与芯片的P27相连，U1的LE与芯片的P26相连（下图所示），所以只需使芯片的P27输出低电平来关闭U2锁存器，P26输出高电平来打开U1锁存器。

<div align="center"><img src="https://img1.imgtp.com/2023/08/02/bnylXnC9.png"></div>

打开U1锁存器后，使数码管显示某个数字，我们在第一节中总结过了，比如显示一个数字“6”，需要a、c、d、e、f、g六个LED亮，所以锁存器输出01111101（共阴极数码管。输出1时点亮），即P0寄存器输出01111101，P0寄存器的状态值为0x7d。

<div align="center"><img src="https://img1.imgtp.com/2023/08/02/Utwx2vNE.png"></div>
<div align="center"><img src="https://img1.imgtp.com/2023/08/02/ArNctA1Q.png"></div>

## 2.代码练习
接下来再写代码的过程中，请反复看这张图，了解其中的原理
<div align="center"><img src="https://img1.imgtp.com/2023/08/02/H3IjuOno.png"></div>

### （1）静态数码管显示
#### 1.1 数码管的某一位显示一个数字
```c
#include <REGX52.H>
int main()
{
	P2_4=1;
	P2_3=0;
	P2_2=1;
	P0=0x7D;
	while(1)
	{
		
	}
}
```
以上代码让数码管的第三位显示为6

	那么如果我们要第④位显示数字⑥的话该怎么办？很简单把P2_4=1；P2_3=0；P2_2=0；

	LED会亮的原因是因为引脚冲突这个不需要去管它。

<div align="center"><img src="https://img1.imgtp.com/2023/08/02/HNMe8ZSW.png"></div>


#### 1.2静态数码管显示
```c
#include <REGX52.H>
//                          0    1    2    3    4    5    6    7    8    9
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
 
//Location:数码管的位置;	Number:显示数码管的数字【高电平点亮段码】	
void Nixie(unsigned char Location,Number)
{
	switch(Location)		  //位码端输出
	{
        //开发板上是逆序为1
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0 = NixieTable[Number]; //P0接收数码管中的数字
}
int main(void)
{
	Nixie(2,2);
	while(1)
	{
		
	}
}

```

### （2）动态数码管显示
```c
#include <REGX52.H>
 
//数码管段码表
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
 
//延时子函数
void Delay(unsigned int xms)
{
	unsigned char i, j;
	while(xms--)
	{
		i = 2;
		j = 239;
		do
		{
			while (--j);
		} while (--i);
	}
}
 
//数码管显示子函数
void Nixie(unsigned char Location,Number)
{
	switch(Location)		//位码输出
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];	//段码输出
	Delay(1);				//显示一段时间
	P0=0x00;				//段码清0，消影
}
 
int main(void)
{
	while(1)
	{
		Nixie(1,1);		//在数码管的第1位置显示1
//		Delay(20);
		Nixie(2,2);		//在数码管的第2位置显示2
//		Delay(20);
		Nixie(3,3);		//在数码管的第3位置显示3
//		Delay(20);
	}
}

```
那么在这里解释下数码管的消影就是比方说：

当我们要显示数码管的时候首先要：位选 段选、还要显示的话就还要 位选、段选，循环。

那么这样就会出现问题：首先是选择"位选端"给上低电平，然后是段选给上数据，然后给上下一位位选的数据。但是：由于我们单片机的速度是很快的，在段选到下一个位选之间就会出现问题。我们选中下一位这个时刻很短的时间内，上一个数据就会串到下一个数据。因为它们是挨着一起的，我在选中下一位之后 上一位的数据自然是会直接过来的。这样就会显示出数据的串位的问题了！

那么我们应该怎么避免这个问题？那我们就需要在上一个段选端给清零这样即使到下一位它也不会对上一位产生影响！因为以及清零了。所以在子函数上需要优化下，显示玩之后我们首先要延迟1ms这个是为了能让程序更加稳定显示(不会变暗) 并且 进行清零！

## 3.数码管的驱动方式
<div align="center"><img src="https://img1.imgtp.com/2023/08/05/xCuybsqt.png"></div>

 静态驱动也称直流驱动。静态驱动是指每个数码管的每一个段码都由一个的单片机I/O口进行驱动，或者使用如BCD码二-十进制译码器译码进行驱动。  

 * 静态驱动的优点是编程简单，显示亮度高，缺点是占用I/O端口多。

 数码管动态显示接口是单片机中应用最为广泛的一种显示方式之一，动态驱动是将所有数码管的8个显示笔划"a,b,c,d,e,f,g,dp"的同名端连在一起，另外为每个数码管的公共极COM增加位选通控制电路，位选通由各自独立的I/O线控制，当单片机输出字形码时，所有数码管都接收到相同的字形码，但究竟是哪个数码管会显示出字形，取决于单片机对位选通COM端电路的控制，所以我们只要将需要显示的数码管的选通控制打开，该位就显示出字形，没有选通的数码管就不会亮。通过分时轮流控制各个数码管的的COM端，就使各个数码管轮流受控显示，这就是动态驱动。在轮流显示过程中，每位数码管的点亮时间为1～2ms，由于人的视觉暂留现象及发光二极管的余辉效应，尽管实际上各位数码管并非同时点亮，但只要扫描的速度足够快，给人的印象就是一组稳定的显示数据，不会有闪烁感，动态显示的效果和静态显示是一样的。 

* ​​​​​​动态驱动的优点是能够节省大量的I/O端口，而且功耗更低。缺点是花费cpu占用时间，编程较为复杂。