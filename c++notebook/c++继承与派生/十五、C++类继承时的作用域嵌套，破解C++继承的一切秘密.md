# 十五、C++类继承时的作用域嵌套，破解C++继承的一切秘密
类其实也是一种作用域，每个类都会定义它自己的作用域，在这个作用域内我们再定义类的成员，这一点已在《类其实也是一种作用域》中讲到。当存在继承关系时，派生类的作用域嵌套在基类的作用域之内，如果一个名字在派生类的作用域内无法找到，编译器会继续到外层的基类作用域中查找该名字的定义。

换句话说，作用域能够彼此包含，被包含（或者说被嵌套）的作用域称为内层作用域（inner scope），包含着别的作用域的作用域称为外层作用域（outer scope）。一旦在外层作用域中声明（或者定义）了某个名字，那么它所嵌套着的所有内层作用域中都能访问这个名字。同时，允许在内层作用域中重新定义外层作用域中已有的名字。

派生类的作用域位于基类作用域之内这一事实可能有点出人意料，毕竟在我们的代码中派生类和基类的定义是相互分离的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样来使用基类的成员。

```c++
#include<iostream>
using namespace std;
class A{
public:
    void func();
public:
    int n;
};
void A::func(){ cout<<"c.biancheng.net"<<endl; }
class B: public A{
public:
    int n;
    int m;
};
class C: public B{
public:
    int n;
    int x;
};
int main(){
    C obj;
    obj.n;
    obj.func();
    cout<<sizeof(C)<<endl;
    return 0;
}
```
    运行结果：
    c.biancheng.net
    20
本例中，B 继承自 A，C继承自 B

obj 是 C 类的对象，通过 obj 访问成员变量 n 时，在 C 类的作用域中就能够找到了 n 这个名字。虽然 A 类和 B 类都有名字 n，但编译器不会到它们的作用域中查找，所以是不可见的，也即派生类中的 n 遮蔽了基类中的 n。

通过 obj 访问成员函数 func() 时，在 C 类的作用域中没有找到 func 这个名字，编译器继续到 B 类的作用域（外层作用域）中查找，仍然没有找到，再继续到 A 类的作用域中查找，结果就发现了 func 这个名字，于是查找结束，编译器决定调用 A 类作用域中的 func() 函数。

这个过程叫做名字查找（name lookup），也就是在作用域链中寻找与所用名字最匹配的声明（或定义）的过程。
# C++继承时的对象模型问题
当没有继承时对象内存的模型很简单，此时成员变量和成员函数会分开存储  
* 对象的内存中只包含成员变量，存储在栈区或堆区（使用 new 创建对象）；
* 成员函数与对象内存分离，存储在代码区。

当存在继承关系时，内存模型会稍微复杂一些：


在派生类的对象模型中，会包含所有基类的成员变量。这种设计方案的优点是访问效率高，能够在派生类对象中直接访问基类变量，无需经过好几层间接计算。