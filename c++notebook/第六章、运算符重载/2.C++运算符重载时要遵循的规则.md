运算符重载是通过函数重载实现的，概念上大家都很容易理解，这节我们来说一下运算符重载的注意事项。


1) 并不是所有的运算符都可以重载。能够重载的运算符包括：  

        +  -  * /  %  ^  &  |  ~  !  =  <  >  +=  -=  *=  /=  %=  ^=  &=  |=  <<  >>  <<=  >>=  ==  !=  <=  >=  &&  ||  ++  --  ,  ->*  ->  ()  []  new  new[]  delete  delete[]

上述运算符中，[]是下标运算符，()是函数调用运算符。自增自减运算符的前置和后置形式都可以重载。长度运算符sizeof、条件运算符: ?、成员选择符.和域解析运算符::不能被重载。

2) 重载不能改变运算符的优先级和结合性。假设上一节的 complex 类中重载了+号和*号，并且 c1、c2、c3、c4 都是 complex 类的对象，那么下面的语句：

    c4 = c1 + c2 * c3;

等价于：

    c4 = c1 + ( c2 * c3 );

乘法的优先级仍然高于加法，并且它们仍然是二元运算符。

3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。例如~号右边只有一个操作数，+号总是出现在两个操作数之间，重载后也必须如此。

4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。

5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数。

将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。

例如，上节的 complex 类中重载了加法运算符：

    complex operator+(const complex & A) const;

当执行：

    c3 = c1 + c2;

会被转换为：

    c3 = c1.operator+(c2); //成员函数情况

通过 this 指针隐式的访问 c1 的成员变量。

将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。

例如，下面这样是不对的：

```c++
int operator + (int a,int b){
    return (a-b);
}
```

+号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式4+3的结果是 7 还是 1 呢？显然，这是绝对禁止的。

如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C ++内置类型的数据，例如：

```c++
complex operator+(int a, complex &c){
    return complex(a+c.real, c.imag);
}
```

它的作用是使一个整数和一个复数相加。

另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数。原因很简单，该函数大部分情况下都需要使用类的 private 成员。

上节的最后一个例子中，我们在全局范围内重载了+号，并在 complex 类中将运算符重载函数声明为友元函数，因为该函数使用到了 complex 类的 m_real 和 m_imag 两个成员变量，它们都是 private 属性的，默认不能在类的外部访问。


6) 箭头运算符->、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。