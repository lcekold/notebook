当处理输入输出时，我们必须预计到其中可能发生的错误并给出相应的处理措施。

* 当我们输入时，可能会由于人的失误（错误理解了指令、打字错误、允许自家的小猫在键盘上散步等）、文件格式不符、错误估计了情况等原因造成读取失败。

* 当我们输出时，如果输出设备不可用、队列满或者发生了故障等，都会导致写入失败。

发生输入输出错误的可能情况是无限的！但 C++ 将所有可能的情况归结为四类，称为流状态（stream state）。每种流状态都用一个 iostate 类型的标志位来表示。
----
<div align="center">流状态对应的标志位</div>

|  标志位 |                                                    意义                                                   |   |
|:-------:|:---------------------------------------------------------------------------------------------------------:|---|
| badbit  | 发生了（或许是物理上的）致命性错误，流将不能继续使用。                                                    |   |
| eofbit  | 输入结束（文件流的物理结束或用户结束了控制台流输入，例如用户按下了 Ctrl+Z 或 Ctrl+D 组合键。              |   |
| failbit | I/O 操作失败，主要原因是非法数据（例如，试图读取数字时遇到字母）。流可以继续使用，但会设置 failbit 标志。 |   |
| goodbit | 一切止常，没有错误发生，也没有输入结束。                                                                  |   |
-----
ios_base 类定义了以上四个标志位以及 iostate 类型，但是 ios 类又派生自 ios_base 类，所以可以使用 ios::failbit 代替 ios_base::failbit 以节省输入。

一旦流发生错误，对应的标志位就会被设置，我们可以通过下表列出的函数检测流状态。

------
<div align="center">C++流状态检测函数及其说明</div>


| 检测函数 | 对应的标志位 |                               说明                               |
|:--------:|:------------:|:----------------------------------------------------------------:|
| good()   | goodbit      | 操作成功，没有发生任何错误。                                     |
| eof()    | eofbit       | 到达输入末尾或文件尾。                                           |
| fail()   | failbit      | 发生某些意外情况（例如，我们要读入一个数字，却读入了字符 'x'）。 |
| bad()    | badbit       | 发生严重的意外（如磁盘读故障）。                                 |

------

不幸的是，fail() 和 bad() 之间的区别并未被准确定义，程序员对此的观点各种各样。但是，基本的思想很简单：

* 如果输入操作遇到一个简单的格式错误，则使流进入 fail() 状态，也就是假定我们（输入操作的用户）可以从错误中恢复。

* 如果错误真的非常严重，例如发生了磁盘故障，输入操作会使得流进入 bad() 状态。也就是假定面对这种情况你所能做的很有限，只能退出输入。

以上观点导致如下逻辑：

```c++
int i = 0;
cin >> i;
if(!cin){  //只有输入操作失败，才会跳转到这里
    if(cin.bad()){  //流发生严重故障，只能退出函数
        error("cin is bad!");  //error是自定义函数，它抛出异常，并给出提示信息
    }
    if(cin.eof()){  //检测是否读取结束
        //TODO:
    }
    if(cin.fail()){  //流遇到了一些意外情况
        cin.clear(); //清除/恢复流状态
        //TODO:
    }
}
```

!cin 可以理解为“cin 不成功”或者“cin 发生了某些错误”或者“ cin 的状态不是 good()”， 这与“操作成功”正好相反，《C++ cin判断输入结束》一节中对此有详解。

请注意我们在处理 fail() 时所使用的 cin.clear()。当流发生错误时，我们可以进行错误恢复。为了恢复错误，我们显式地将流从 fail() 状态转移到其他状态，从而可以继续从中读取字符。clear() 就起到这样的作用——执行 cin.clear() 后，cin 的状态就变为 good()。

# 实例

下面是一个如何使用流状态的例子。假定我们要读取一个整数序列并存入 vector 中，字符*或“文件尾”表示序列结束。Windows 平台按下 Ctrl+Z 组合键，再按下回车键表示到达文件末尾；类Unix系统按下 Ctrl+D 组合键表示到达文件末尾。

上述功能可通过如下函数来实现：

```c++
//从 ist 中读入整数到 v 中，直到遇到 eof() 或终结符
void fill_vector(istream& ist, vector<int>& v, char terminator){
    for( int i; ist>>i; ) v.push_back(i);

    //正常情况
    if(ist.eof()) return;  //发现到了文件尾，正确，返回

    //发生严重错误，只能退出函数
    if (ist.bad()){
        error("cin is bad!");  //error是自定义函数，它抛出异常，并给出提示信息
    }

    //发生意外情况
    if (ist.fail()) {  //最好清除混乱，然后汇报问题
        ist.clear();  //清除流状态

        //检测下一个字符是否是终结符
        char c;
        ist>>c;  //读入一个符号，希望是终结符
        if(c != terminator) { // 非终结符
            ist.unget(); //放回该符号
            ist.clear(ios_base::failbit);  //将流状态设置为 fail()
        }
    }
}
```

如果发生了 fail()，我们尝试检测下一个字符是否是结束符：如果是，那么就完整得读取了数据，使用 clear() 恢复状态就可以；如果不是，我们就没有办法处理了，所以将状态重新设置为 fail()，以期望 fill_vector() 的调用者（上层函数）有能力处理。

我们通过调用 ist.clear(ios_base::failbit) 来将流状态设置为 fail()。对照简单的cleal()，带参数的用法有些令人迷惑：当 clear() 带参数时，参数中所指出的 iostream 状态位会被置位（进入相应状态)，而未指出的状态位会被复位。通过将流状态设置为 fail()，我们表明遇到了一个格式错误，而不是一个更为严重的问题。

可以用 unget() 将字符放回 ist，以便 fill_vector() 的调用者可能使用该字符。unget() 函数是 putback() 的简化版本，它依赖于流对象记住最后一个字符是什么，所以在这里可以不用考虑它的用法。

如果 fill_vector() 的调用者想知道是什么原因终止了输入，那么可以检测流是处于 fail() 还是 eof() 状态。当然也可以捕获 error() 抛出的 runtime_error 异常，但当 istream 处于 bad() 状态时，继续获取数据是不可能的。大多数的调用者无须为此烦恼。因为这意味着，几乎在所有情况下，对于 bad() 状态，我们所能做的只是抛出一个异常。

简单起见，可以让 istream 帮我们抛出这个异常。

    //当 ist 出现问题时拋出异常
    ist.exceptions(ist.exceptions() | ios_base:: badbit);

这样的写法也许看起来有些奇怪，但结果却很简单，当此语句执行时，如果 ist 处于 bad() 状态，它会抛出一个标准库异常 ios_base::failure。在一个程序中，我们只需要调用 exceptions() 一次。这允许我们简化关联于 ist 的所有输入过程，同时忽略对 bad() 的处理：

```c++
//从ist中读入整数到v中，直到遇到eof()或终结符
void fill_vector(istream& ist, vector<int>& v, char terminator){
    ist.exceptions(ist.exceptions() | ios_base:: badbit);

    for (int i; ist>>i; ) v.push_back(i);

    if (ist.eof()) return;  //发现到了文件尾

    //不是good()，不是bad()，不是eof()，ist的状态一定是fail()
    ist.clear();  //清除流状态

    char c;
    ist>>c;    //读入一个符号，希望是终结符
    if (c != terminator) { //不是终结符号，一定是失败了
        ist.unget();    //也许程序调用者可以使用这个符号
        ist.clear(ios_base::failbit); //将流状态设置为 fail()
    }
}
```

这里使用了 ios_base，它是 iostream 的一部分，包含了对常量如 badbit 的定义、异常如 failure 的定义，以及其他一些有用的定义。可以通过::操作符来使用它们，例如 ios_ base::badbit。

我们无须如此深入地讨论 iostream 库的细节，若要学习 iostream的所有内容，可能需要一门完整的课程。例如，iostream 可以处理不同的字符集，实现不同的缓冲策略，还包含一些工具，能按不同语言的习惯格式化货币金额的输入输出。我们曾经收到过一份关于乌克兰货币输入输出格式的错误报告。如果需要了解更多 iostream 库的内容，可以参考 Stroustrup 的《The C++ Programming Language》和 Langer 的《Standard C++ IOStreams and Locales》。

与 istream—样，ostream 也有四个状态：good()、fail()、eof() 和 bad()。不过，对于本教程的读者来说，输出错误要比输入错误少得多，因此通常不对 ostream 进行状态检测。如果程序运行环境中输出设备不可用、队列满或者发生故障的概率很高，我们就可以像处理输入操作那样，在每次输出操作之后都检测其状态。

