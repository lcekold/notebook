通过页表完成虚拟地址和物理地址的映射时，要经过多次转换，还要进行计算，如果由操作系统来完成这项工作，那将会成倍降低程序的性能，得不偿失，所以这种方式是不现实的。

# MMU

在CPU内部，有一个部件叫做MMU（Memory Management Unit，内存管理单元），由它来负责将虚拟地址映射为物理地址，如下图所示：

<div align="center"><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/c++note/52.jpg"></div>

在页映射模式下，CPU 发出的是虚拟地址，也就是我们在程序中看到的地址，这个地址会先交给 MMU，经过 MMU 转换以后才能变成了物理地址。

即便是这样，MMU也要访问好几次内存，性能依然堪忧，所以在MMU内部又增加了一个缓存，专门用来存储页目录和页表。MMU内部的缓存有限，当页表过大时，也只能将部分常用页表加载到缓存，但这已经足够了，因为经过算法的巧妙设计，可以将缓存的命中率提高到 90%，剩下的10%的情况无法命中，再去物理内存中加载页表。

有了硬件的直接支持，使用虚拟地址和使用物理地址相比，损失的性能已经很小，在可接受的范围内。

MMU 只是通过页表来完成虚拟地址到物理地址的映射，但不会构建页表，构建页表是操作系统的任务。在程序加载到内存以及程序运行过程中，操作系统会不断更新程序对应的页表，并将页目录的物理地址保存到 CR3 寄存器。MMU 向缓存中加载页表时，会根据 CR3 寄存器找到页目录，再找到页表，最终通过软件和硬件的结合来完成内存映射。

    CR3 是CPU内部的一个寄存器，专门用来保存页目录的物理地址。

每个程序在运行时都有自己的一套页表，切换程序时，只要改变 CR3 寄存器的值就能够切换到对应的页表。

# 对内存权限的控制

MMU 除了能够完成虚拟地址到物理地址的映射，还能够对内存权限进行控制。上节《内存分页机制的实现（虚拟地址和物理地址的映射）》讲到，在页表数组中，每个元素占用4个字节，也即32位，我们使用高20位来表示物理页编号，还剩下低12位，这12位就用来对内存进行控制，例如，是映射到物理内存还是映射到磁盘，程序有没有访问权限，当前页面有没有执行权限等。

操作系统在构建页表时将内存权限定义好，当MMU对虚拟地址进行映射时，首先检查低12位，看当前程序是否有权限使用，如果有，就完成映射，如果没有，就产生一个异常，并交给操作系统处理。操作系统在处理这种内存错误时一般比较粗暴，会直接终止程序的执行。

请看下面的代码：

```c
#include <stdio.h>
int main() {
    char *str = (char*)0XFFF00000;  //使用数值表示一个明确的地址
    printf("%s\n", str);
    return 0;
}
```

这段代码不会产生编译和链接错误，但在运行程序时，为了输出字符串，printf() 需要访问虚拟地址为 0XFFFF00000 的内存，但是该虚拟地址是被操作系统占用的（下节会讲解），程序没有权限访问，会被强制关闭，如下图所示：

<div align="center"><img src="https://cdn.jsdelivr.net/gh/lcekold/blogimage@main/c++note/32.png"></div>

而在Linux下，会产生段错误（Segment Fault），相信大家在编程过程中会经常见到这种经典的内存错误。