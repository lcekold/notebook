# 1.定义详解
**1.头结点：**

（1）数据结构中，在单链表的开始结点之前设立一个节点称之为头结点，头结点的数据域可以不存储任何信息，也可以存储链表的长度等附加信息，头结点的指针域存储指向第一个结点的指针（即第一个结点的存储位置）。
 
     （2）作用：方便链表的操作，减少代码量，举个例子，要知道在链表中插入，删除一个元素是更改这个结点上一个结点的指针域的位置来实现的，那么怎么样来对第一个结点来进行这些操作，有，但是麻烦，不如引入一个头结点来的方便。总之，引入头结点就可以很少的考虑到一些特殊情况，减少代码量。

**2.头指针:**

注意注意**注意

（1）头指针是指链表中 ，指向第一个结点的指针。 这一点很重要

      （2）头指针具有标识作用，所以常常会用头指针冠以链表的名字。所以你定义一个链表，那么链表的名字一般就是这个链表的头指针。

（3）无论链表是否为空，头指针均不为空，头指针是链表的必要元素。

# 2.疑难杂症解析

## 1.为什么必须要有头指针?

答:在链表当中，头指针相当于链表本身，在很多演示当中因此头指针的名字往往也是链表本身的名字，通过头指针可以实现对链表的遍历查找等操作。

有的人可能会问，为什么不能通过首元结点来实现对链表的遍历查找等操作呢？ 原因在于，对链表的操作时首元结点往往会发生变动，比如说：

    temp=temp->next  //其中temp为首元结点

这样的话通过首元结点便无法指代整个链表。举个更加具体的例子：

```c++
link * initLink(){
    link * p=NULL;//创建头指针
    link * temp = (link*)malloc(sizeof(link));//创建首元节点
    //首元节点先初始化
    temp->elem = 1;
    temp->next = NULL;
    p = temp;//头指针指向首元节点
    //从第二个节点开始创建
    for (int i=2; i<5; i++) {
     //创建一个新节点并初始化
        link *a=(link*)malloc(sizeof(link));
        a->elem=i;
        a->next=NULL;
        //将temp节点与新建立的a节点建立逻辑关系
        temp->next=a;
        //指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对
        temp=temp->next;
    }
    //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表
    return p;
}
```
上述代码对链表进行了一个简单的初始化，最后一步return p返回的是链表的头指针，但是有的人可能会问为什么不能return temp呢？原因是在循环当中temp=temp->next导致temp指代的结点一直在发生变化。


## 2.头结点有什么作用？

头结点并不是必须要有的，但没有头结点实现很多功能会相当麻烦，如果没有头结点，头指针会直接指向首元结点，如果我们要对首元结点进行操作会相当麻烦，比如我们删除第一个元素的结点，就必须重新改变一次头指针的指向

但是，如果我们引入头结点之后，操作就会方便许多，因为无论我们对元素如何处理，头指针始终指向头结点，我们对于首元元素的处理也就不需要考虑头指针的指向问题。

## 3.如果说没有头结点会怎么处理结点呢，尤其是对于处理第一个元素的情况？

答：一般情况会引入虚拟头结点

