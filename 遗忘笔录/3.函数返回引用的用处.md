# 函数返回引用有什么用？

函数返回引用在 C++ 中具有一些特殊的用途和好处：

1. 修改函数调用者的值：通过返回引用，可以在函数内部修改函数调用者传递给函数的变量或对象的值，从而避免了创建副本并提高了代码的效率。这对于需要修改函数参数或返回类型的函数非常有用。

2. 实现链式操作：返回引用允许多个函数调用链接在一起形成连续的表达式。这样可以提高代码的可读性和简洁性。例如，C++ 的流式输入输出 (iostream) 库就使用了函数返回引用来实现连续的输入输出操作。

3. 返回对象成员的引用：某些情况下，我们希望访问或修改对象中的某个成员变量。通过返回成员变量的引用，可以直接访问该成员并进行修改，而无需暴露整个对象的实现细节。

需要注意的是，返回引用时应注意以下几点：

* 返回引用时，要确保返回的引用所引用的对象或变量在函数执行完毕后仍然有效。避免返回局部变量的引用，因为局部变量在函数执行完毕后会被销毁。
* 当返回引用时，应确保返回的引用不会被用于悬空引用。也就是说，返回的引用应始终引用有效的对象或变量，避免引用被访问已经销毁的对象。
* 返回引用时，应当清晰地注明引用的作用和生命周期，并确保对被引用对象的访问是安全的。

总的来说，返回引用在适当的情况下可以提供编程灵活性和性能优势，但需要谨慎使用，避免引发悬空引用或访问无效内存的问题。

## 例子


### 1.实现链式操作的举例：

当函数返回引用时的一个示例是操作符重载中的赋值操作符（=）重载。在这种情况下，赋值操作符返回一个引用，允许进行连续的赋值操作。

考虑一个简单的类 MyInt，表示一个整数，并重载了赋值操作符：

```c++
class MyInt {
private:
    int value;
    
public:
    MyInt(int val) : value(val) {}
    
    // 赋值操作符的重载
    MyInt& operator=(const MyInt& other) {
        value = other.value;
        return *this;  // 返回当前对象的引用
    }
    
    int getValue() const {
        return value;
    }
};
```

在这个示例中，赋值操作符重载（operator=）被定义为返回 MyInt&，表示返回 MyInt 对象的引用。

现在，我们可以使用赋值操作符进行连续的赋值操作：

```c++
int main() {
    MyInt a(10);
    MyInt b(20);
    MyInt c(30);
    
    a = b = c = MyInt(40);
    
    cout << a.getValue() << endl;  // 输出：40
    cout << b.getValue() << endl;  // 输出：40
    cout << c.getValue() << endl;  // 输出：40
    
    return 0;
}
```

在上述代码中，我们使用了连续赋值操作符，将 MyInt 对象之间的值进行连续赋值。通过返回引用，允许将同一个赋值操作符应用于多个对象，并将最后一个对象的值赋给所有对象。

这样的链式赋值操作符可以提高代码的可读性和简洁性，并且能够在单个语句中完成多个赋值操作，方便编程人员进行代码编写。

### 2.通过返回成员变量的引用，直接访问该成员并进行修改的例子

当我们希望访问或修改对象中的某个成员变量时，返回成员变量的引用可以提供方便和灵活性。下面是一个示例：

```c
#include <iostream>
#include <string>

class Person {
private:
    std::string name;
    int age;

public:
    Person(const std::string& n, int a) : name(n), age(a) {}

    std::string& getName() {
        return name;  // 返回 name 成员变量的引用
    }

    int& getAge() {
        return age;  // 返回 age 成员变量的引用
    }
};

int main() {
    Person john("John", 25);
    
    // 通过返回的引用修改 name 成员变量的值
    john.getName() = "Johnny";
    
    // 通过返回的引用修改 age 成员变量的值
    john.getAge() = 26;
    
    // 输出修改后的成员变量值
    std::cout << "Name: " << john.getName() << std::endl;  // 输出：Name: Johnny
    std::cout << "Age: " << john.getAge() << std::endl;    // 输出：Age: 26
    
    return 0;
}
```

在上述示例中，我们定义了一个名为 Person 的类，其中包含了两个私有成员变量 name 和 age。然后，我们提供了两个公共的成员函数 getName() 和 getAge()，它们分别返回 name 和 age 成员变量的引用。

通过返回成员变量的引用，我们可以直接访问并修改 Person 对象中的特定成员变量，而无需暴露整个对象的实现细节。

在主函数中，我们创建了一个 Person 对象 john，并通过调用 getName() 和 getAge() 同时返回的引用来修改其成员变量 name 和 age 的值。

最后，我们输出修改后的成员变量值，并可见已成功修改了对象中的成员变量。

这种方式可以让我们在需要直接访问和修改对象中的某个成员变量时，提供了更直接、简洁的编程方式，并且可以隐藏对象内部的实现细节。

Array 是一个类模板，它有一个类型参数T和一个非类型参数N，T 指明了数组元素的类型，N 指明了数组长度。

capacity() 成员函数是 Array 类的关键，它使得数组容量可以动态地增加或者减小。传递给它一个正数时，数组容量增大；传递给它一个负数时，数组容量减小。

之所以能通过[ ]来访问数组元素，是因为在 Array 类中以成员函数的形式重载了[ ]运算符，并且返回值是数组元素的引用。如果直接返回数组元素的值，那么将无法给数组元素赋值。

# 非类型参数的限制

非类型参数的类型不能随意指定，它受到了严格的限制，只能是一个整数，或者是一个指向对象或函数的指针（也可以是引用）。引用和指针在本质上是一样的，我们已在《引用在本质上是什么，它和指针到底有什么区别》中讲到。

1) 当非类型参数是一个整数时，传递给它的实参，或者由编译器推导出的实参必须是一个常量表达式，例如10、2 * 30、18 + 23 - 4等，但不能是n、n + 10、n + m等（n 和 m 都是变量）。

对于上面的 Swap() 函数，下面的调用就是错误的：

```c++
int len;
cin>>len;
int a[len];
int b[len];
Swap(a, b);
```

对上面的 Array 类，以下创建对象的方式是错误的：

```c++
int len;
cin>>len;
Array<int, len> arr;
```

这两种情况，编译器推导出来的实参是 len，是一个变量，而不是常量。

2) 当非类型参数是一个指针（引用）时，绑定到该指针的实参必须具有静态的生存期；换句话说，实参必须存储在虚拟地址空间中的静态数据区。局部变量位于栈区，动态创建的对象位于堆区，它们都不能用作实参。

